# Model Context Protocol (MCP) Applications

This repository showcases various applications and the usage of the Model Context Protocol (MCP). It includes client-side examples demonstrating how to utilize tools exposed by an MCP server, including agent-based and conversational agent implementations.

![MCP and Agent interface architecture for this project](mcp_agent_hld.png)
---

## üöÄ Overview

The Model Context Protocol (MCP) is designed to facilitate communication and interaction between language models and external tools or services. This repository provides practical examples of how client applications can leverage an MCP server to perform tasks by accessing a suite of pre-defined tools.

---

## üìÇ Files in this Repository

Here's a breakdown of the key files in this project:

* **`application_client.py`**: Contains code for a basic client-side application that utilizes tools from the MCP server. This is a good starting point to understand fundamental MCP client-server interaction.
* **`application_client_with_agents.py`**: Demonstrates a client application that employs an agent to interact with tools available on the MCP server. This shows a more autonomous way of using MCP tools.
* **`application_client_with_conversational_agents.py`**: Features a client-side conversational agent (chatbot) application. This example showcases how to use multiple tools from the MCP server in a conversational context and how to achieve structured output from MCP tools within the agent's responses through prompt engineering.
* **`mcp_server.py`**: This file contains the MCP server code. It's responsible for initializing and exposing various tools, including:
    * `search_tool`
    * `google_navigation_tool`
    * `weather_forecast_tool`
    * `weather_alert_tool`
    * `nearest_place_search_tool`
* **`pyproject.toml`**: Specifies the project's dependencies and build system configuration, used by modern Python packaging tools like `uv`.
* **`uv.lock`**: A lock file generated by `uv` that ensures reproducible builds by pinning exact versions of dependencies.

---

## üõ†Ô∏è Getting Started

This project uses `uv` as its package manager. `uv` is an extremely fast Python package installer and resolver, written in Rust, and designed as a drop-in replacement for `pip` and `pip-tools` workflows.

### Installing `uv`

You can install `uv` using several methods:

* **Standalone Scripts:**
    * On macOS and Linux:
        ```bash
        curl -LsSf [https://astral.sh/uv/install.sh](https://astral.sh/uv/install.sh) | sh
        ```
    * On Windows:
        ```powershell
        irm [https://astral.sh/uv/install.ps1](https://astral.sh/uv/install.ps1) | iex
        ```
* **Using `pip` (if you have Python and pip already):**
    ```bash
    pip install uv
    ```
* **Running a python script:**
    ```bash
    uv run your_python_script.py
    ```
* **Other methods:** Check the [official `uv` installation guide](https://github.com/astral-sh/uv#installation) for more options (e.g., Homebrew, Cargo).

After installation, verify it by running:
```bash
uv --version
```
[uv vs. pip/conda](#uv-vs-pipconda)
## Setting up the Project Environment with *uv*:

1. **Clone the repository:**

   ```bash
   git clone [<your-repository-url>](https://github.com/Git-of-arnab/Model-Context-Protocol.git)
   cd Model-Context-Protocol
   ```
2. **Create a virtual environment (recommended):**
   ```bash
   uv venv
   ```
   This will create a .venv directory in your project.
   
3. **Activate the virtual environment:**
   * On macOS and Linux:
     ```bash
     source .venv/bin/activate
     ```
   * On Windows (PowerShell):
     ```Powershell
     .venv\Scripts\Activate.ps1
     ```
   * On Windows (CMD):
     ```DOS
     .venv\Scripts\activate.bat
     ```
  4. **Install dependencies:**
     uv will use the pyproject.toml and uv.lock (if present) files to install the required packages.
     The uv pip sync command is often preferred as it synchronizes your environment with the exact versions specified in the uv.lock file (if it exists and is consistent with pyproject.toml), ensuring reproducibility.
     If uv.lock doesn't exist or needs updating based on pyproject.toml, uv will resolve dependencies and can create/update the lock file.
     ```bash
     uv pip sync
     ```
     Alternatively, if you want to compile pyproject.toml to a requirements.txt first (though uv handles pyproject.toml directly well):
     ```bash
     # Optional: Compile requirements if needed for other purposes
     # uv pip compile pyproject.toml -o requirements.txt 
     # Then install using the generated requirements file
     # uv pip sync requirements.txt
     ```
## Usage:
* application_client.py:
  ```bash
  uv run application_client.py mcp_server.py
  ```
* application_client_with_agents.py:
  ```bash
  uv run application_client_with_agents.py mcp_server.py
  ```
* application_client_with_conversational_agents.py:
  ```bash
  uv run application_client_with_conversational_agents.py mcp_server.py
  ```

## uv-vs-pipconda

üì¶ uv Package Manager: Pros and Cons

**Pros of uv:**

‚ö° Blazing Speed: uv is significantly faster than pip and conda for dependency resolution and package installation. This is largely due to its Rust implementation and efficient algorithms.

‚õìÔ∏è Improved Dependency Resolution: It features a modern, fast dependency resolver that can often handle complex dependency graphs more quickly and reliably than pip's legacy resolver.

üêç Virtual Environment Management: uv includes built-in commands for creating and managing virtual environments (uv venv), consolidating tooling.You don't have to create virtualenv explictely, when you add packages using "uv add <package_name>" it first creates a virtual env and then
installs the packages inside it.

‚ú® You initialize/create your project using "uv init <project/directory_name>" and it will create hiearchial files(.gitignore,.python-version,main.py,
README.md,pyproject.toml).

**Cons of uv:**

‚è≥ Maturity and Ecosystem: While rapidly developing, uv is newer than pip and conda.
This means it might have fewer edge cases covered, and community support/resources (like Stack Overflow answers) might be less extensive, though this is changing quickly.

üêç Non-Python Packages (vs. Conda): uv focuses on Python packages. Conda, on the other hand, is a language-agnostic package manager and can manage packages from other languages (e.g., R, C++) and complex binary dependencies, which is crucial in scientific computing. uv does not aim to replace this aspect of Conda.

üè¢ Need to run in administrative mode

**uv vs. pip**

* Choose *uv* if: You prioritize speed, modern dependency resolution, and are working primarily with Python packages. Your workflow aligns with pyproject.toml and lock files.
* Stick with *pip* if: You need maximum stability from a long-established tool, rely on specific pip features not yet in uv, or operate in environments where installing new tools is restricted.

**uv vs. conda**
* Choose *uv* if: Your project primarily involves Python packages and you want a very fast installer and resolver within that ecosystem.
* Choose *conda* if: You need to manage non-Python packages, require management of the Python interpreter itself, or work in data science/scientific computing environments where Conda's ability to handle complex binary dependencies and create isolated environments with different Python versions is critical.
